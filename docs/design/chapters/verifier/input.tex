\section{Input Data Structures}

All input data divided into two parts:

\begin{enumerate}
    \item Placeholder proof byteblob itself;
    \item Verification parameters used to verify proof.
\end{enumerate}

\subsection{Placeholder Proof Structure}

Placeholder proof consists of different fields and some of them are of complex structure types, which will be described in top-down order.

So, the first one Placeholder proof has the following structure, which is described in pseudocode:

\begin{verbatim}
    struct PlaceholderProof {
        vector<uint8> witness_commitment
        vector<uint8> v_perm_commitment
        vector<uint8> input_perm_commitment
        vector<uint8> value_perm_commitment
        vector<uint8> v_l_perm_commitment
        vector<uint8> T_commitment
        uint256 challenge
        uint256 lagrange_0
        LPCProof witness
        LPCProof permutation
        LPCProofquotient
        vector<LPCProof> lookups
        LPCProof id_permutation
        LPCProof sigma_permutation
        LPCProof public_input
        LPCProof constant
        LPCProof selector
        LPCProof special_selectors
    }
\end{verbatim}

In turn proof of LPC algorithm has the following structure:

\begin{verbatim}
    struct LPCProof {
        vector<uint8> T_root
        vector<vector<uint256>> z
        vector<FRIProof> fri_proofs
    }
\end{verbatim}

The next one description is for structure of FRI algorithm proof:

\begin{verbatim}
    struct FRIProof {
        vector<vector<uint256>> final_polynomials
        vector<FRIRoundProof> round_proofs
    }
\end{verbatim}

One of the components of the FRI algorithm proof is so called round FRI proof, which has the following structure:

\begin{verbatim}
    struct FRIRoundProof {
        vector<uint256> colinear_value
        vector<uint256> T_root
        MerkleProof colinear_path
        vector<MerkleProof> p
    }
\end{verbatim}

The next important component is the merkle tree proof of the following structure:

\begin{verbatim}
    struct MerkleProof {
        uint64 leaf_index
        vector<uint8> root
        vector<MerkleProofLayer> path
    }
\end{verbatim}

\begin{verbatim}
    struct MerkleProofLayer {
        vector<MerkleProofLayerElement> layer
    }       
\end{verbatim}

In the simplest and used case of the merkle tree with arity 2 layer consists of only one element:

\begin{verbatim}
    struct MerkleProofLayerElement {
        uint64 position
        vector<uint8> hash
    }
\end{verbatim}

It is important to note that before sending Placeholder proof to EVM for verification it should be serialized into byteblob format,
which is done using corresponding marshalling module 
(\url{https://github.com/NilFoundation/crypto3-zk-marshalling/blob/01b531550a99232586e17c1e383e4693a4ddc924/include/nil/crypto3/marshalling/zk/types/placeholder/proof.hpp}).

\subsection{Verification Parameters}

Verification parameters are used to parametrize Placeholder algorithm depending on chosen security parameters and specific circuit for which proof was created.

Following parameters are required to complete Placeholder verification procedure in-EVM:

\begin{verbatim}
    uint256 modulus - modulus of chosen prime field
    uint256 r - parameter of FRI algorithm
    uint256 max_degree - parameter of FRI algorithm
    uint256 lambda - parameter of LPC algorithm
    uint256 rows_amount - parameter defined by chosen circuit
    uint256 omega - parameter defined by chosen circuit
    uint256 max_leaf_size - parameter dependent on specific instance of Placeholder algorithm, equal to max leaf size among all of the instances of batched LPC algorithm used within Placeholder algorithm
    vector<uint256> Domains generators - parameter defined by chosen circuit 
    vector<uint256> q_polynomial - parameter of Placeholder algorithm
    vector<vector<int256>> columns_rotations - parameter defined by chosen circuit
\end{verbatim}
